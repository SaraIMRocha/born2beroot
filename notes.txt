
Q&A 

----------------------------------------------------------------------------------------------

Why did I choose Debian?

Easier to install and configure so better for personal servers.

#What is a Virtual Machine?#

Is a resource that uses software instead of a physical computer to run programs or apps. 
Each VM has its own operating system and functions separately, so you can have more than 
one VM per machine. Can be used to test applications in a safe, separate environment. 
Works by using software to simulate virtual hardware and run on a host machine.

#What is the difference between aptitude and APT (Advanced Packaging Tool)?#

    Aptitude is a high-level package manager while APT is lower level which can be used by 
	other higher level package managers
    Aptitude is smarter and will automatically remove unused packages or suggest installation 
	of dependent packages
    Apt will only do explicitly what it is told to do in the command line

#What is AppArmor?#

Linux security system that provides Mandatory Access Control (MAC) security. 
Allows the system admin to restrict the actions that processes can perform. 
It is included by default with Debian. Run aa-status to check if it is running.
Password Rules

For the password rules, we use the password quality checking library and there are 
two files the common-password file which sets the rules like upper and lower case characters, 
duplicate characters etc and the login.defs file which stores the password expiration rules (30 days etc). Sudo nano /etc/login.defs Sudo nano /etc/pam.d/common-password

#What is LVM#

Logical Volume Manager – allows us to easily manipulate the partitions or logical volume 
on a storage device.

#UFW (Uncomplicated Firewall)#

UFW is a interface to modify the firewall of the device without compromising security. 
You use it to configure which ports to allow connections to and which ports to close. 
This is useful in conjunction with SSH, can set a specific port for it to work with.
What is SSH?

SSH or Secure Shell is an authentication mechanism between a client and a host. 
It uses encryption techniques so that all communication between clients and hosts is 
done in encrypted form. User on Mac or Linux can use SSH the terminal to work on their 
server via SSH.

#What is Cron?#

Cron or cron job is a command line utility to schedule commands or scripts to happen 
at specific intervals or a specific time each day. Useful if you want to set your 
server to restart at a specific time each day.

    cd /usr/local/bin – to show monitoring.sh
    sudo crontab -u root -e – to edit the cron job
    change script to */1 * * * * sleep 30s && script path – to run it every 30 seconds, 
	delete the line to stop the job from running.

Evaluation Commands for UFW, Group, Host, lsblk and SSH

    sudo ufw status
    sudo systemctl status ssh
    getent group sudo
    getent group user42
    sudo adduser new username
    sudo groupadd groupname
    sudo usermod -aG groupname username
    sudo chage -l username - check password expire rules
    hostnamectl
    hostnamectl set-hostname new_hostname - to change the current hostname
    Restart your Virtual Machine.
    sudo nano /etc/hosts - change current hostname to new hostname
    lsblk to display the partitions
    dpkg -l | grep sudo – to show that sudo is installed
    sudo ufw status numbered
    sudo ufw allow port-id
    sudo ufw delete rule number
    ssh your_user_id@127.0.0.1 -p 4242 - do this in terminal to show that SSH to port 4242 is working

----------------------------------------------------------------------------------------------

What a VirtualBox does:

VirtualBox works by creating a virtual environment that simulates a complete 
computer system, including a processor, memory, storage, and input/output devices. 
It provides a platform for you to install and run any operating system you want, 
as if it were running on a real computer.

This is useful for many things, like testing software or running applications that 
require a different operating system than the one you have on your real computer. 
You can also use it to experiment with different configurations without risking 
damage to your real computer.

----------------------------------------------------------------------------------------------

Encrypted partitions are partitions on a storage device, such as a hard drive or 
a solid-state drive, that are encrypted to protect the data they contain. 
Encryption is the process of converting plain text or data into an unreadable format, 
known as ciphertext, using a cryptographic algorithm and a secret key or passphrase.

When a partition is encrypted, the data on it is protected from unauthorized access, 
even if the storage device is lost or stolen. To access the data on an encrypted Encrypted 
partitions are partitions on a storage device, such as a hard drive or a solid-state drive, 
that are encrypted to protect the data they contain. Encryption is the process of converting 
plain text or data into an unreadable format, known as ciphertext, using a cryptographic 
algorithm and a secret key or passphrase.

When a partition is encrypted, the data on it is protected from unauthorized access, even 
if the storage device is lost or stolen. To access the data on an encrypted partition, 
a user needs to provide the correct passphrase or key to decrypt it.

Encrypted partitions are commonly used for storing sensitive information, such as personal 
or financial data, confidential business information, or classified government information. 
They are also used to protect the privacy of data stored on portable devices, such as 
laptops or USB drives, which can be easily lost or stolen.

Encrypting partitions can be done using different software or tools, such as LUKS, 
VeraCrypt, or BitLocker, depending on the operating system and the type of storage device. 
When creating an encrypted partition, it is important to choose a strong passphrase or key 
and to store it securely, as losing the passphrase or key can result in permanent loss of 
data.partition, a user needs to provide the correct passphrase or key to decrypt it.

Encrypted partitions are commonly used for storing sensitive information, such as personal o
r financial data, confidential business information, or classified government information. 
They are also used to protect the privacy of data stored on portable devices, such as laptops 
or USB drives, which can be easily lost or stolen.

----------------------------------------------------------------------------------------------

Difference between Aptitude and Apt

Both aptitude and apt are command-line tools used for managing packages on Debian-based 
Linux systems, but there are some key differences between them. Here are the main differences:

    User Interface: Aptitude has a user-friendly text-based interface that allows users to 
	interactively manage packages, browse package information, and resolve dependencies. 
	Apt, on the other hand, has a simple command-line interface that requires users to 
	specify commands and options explicitly.

    Command Syntax: Aptitude uses a more flexible and intuitive command syntax that supports 
	advanced package management tasks, such as package pinning, package hold, and package 
	selection based on various criteria. Apt, on the other hand, has a more basic and 
	straightforward command syntax that focuses on installing, updating, and removing packages.

    Package Management: Aptitude uses a more comprehensive and powerful package management 
	system that allows users to perform actions like package searches, package installations 
	and removals, package updates and upgrades, and package downgrades. 
	Apt has a more streamlined package management system that primarily focuses on package 
	installation and removal.

    Package Selection: Aptitude allows users to select packages based on various criteria, 
	such as package name, package description, package dependencies, and package status. 
	Apt, on the other hand, primarily uses package names to select packages.

    Recommended Packages: Aptitude considers recommended packages as dependencies and 
	installs them by default unless explicitly instructed not to do so. Apt, on the other 
	hand, treats recommended packages as optional and does not install them by default 
	unless instructed to do so.

Overall, Aptitude is more powerful and flexible than Apt, but it also has a steeper 
learning curve and a more complex interface. Apt is more straightforward and easier 
to use but has fewer advanced features.

----------------------------------------------------------------------------------------------

What is SELinux

SELinux (Security-Enhanced Linux) is a Linux kernel security module that provides enhanced 
access control and mandatory access control (MAC) for processes and files on a system. 
It was originally developed by the United States National Security Agency (NSA) and has 
since been adopted by various Linux distributions, including Fedora, Red Hat Enterprise Linux, 
CentOS, and Debian.

SELinux uses a set of security policies and rules to control how processes and users interact 
with files, network resources, and system components. It provides a finer-grained access 
control than the traditional Unix-style discretionary access control (DAC) model, which 
allows users and processes to access any object they have permission to access. 
With SELinux, users and processes are granted access based on the security policies defined 
in the SELinux policy.

SELinux works by labeling files, processes, and network resources with security contexts, 
which are used to determine whether a process or user is allowed to access them. 
Security contexts include labels for user identity, role, type, and level. 
These labels are used to define policies that enforce a set of rules governing how users 
and processes can interact with system resources.

SELinux policies can be customized to suit the specific security requirements of a system, 
and the policies can be updated or modified without requiring a system reboot. 
The policies can also be used to detect and prevent security breaches, such as privilege 
escalation attacks, buffer overflows, and code injection attacks.

In summary, SELinux provides a powerful and flexible framework for enforcing mandatory 
access control and enhancing the security of Linux-based systems.

----------------------------------------------------------------------------------------------

What is AppArmor

AppArmor is a Linux kernel security module that provides a mandatory access control (MAC) 
system for restricting the capabilities and actions of individual applications on a system. 
It was originally developed by Immunix Inc. and later acquired by Novell.

AppArmor works by enforcing security policies that specify what actions an application is 
allowed to perform and what resources it can access. These policies are created using 
profiles, which define the permissions and restrictions for individual applications.

AppArmor profiles are designed to be flexible and can be customized to meet the specific 
security requirements of an application or system. Profiles can be created for any application, 
including system daemons, web servers, database servers, and desktop applications.

When an application is launched, the AppArmor security module checks its profile to ensure that 
it is allowed to perform the requested actions and access the required resources. 
If the requested action or resource is not allowed by the profile, the action is blocked and 
an alert is generated.

AppArmor is often used in combination with other security modules, such as SELinux and 
grsecurity, to provide multiple layers of security for Linux-based systems. 
It is included in many popular Linux distributions, such as Ubuntu, Debian, and openSUSE.

In summary, AppArmor is a flexible and powerful security module for Linux-based systems 
that provides mandatory access control and enhances the security of individual applications 
by restricting their capabilities and actions.

----------------------------------------------------------------------------------------------

A SSH service will be running on port 4242 only. For security reasons, it must not be
possible to connect using SSH as root.

In the context of the borntoberoot project, the requirement that it must not be possible 
to connect using SSH as root means that the root user account should be disabled or 
restricted from using SSH to log in to the system remotely.

By default, many Linux distributions allow the root user to connect to the system using SSH, 
which can be a security risk as it provides attackers with full administrative privileges 
on the system. Therefore, it is recommended to disable or restrict root SSH access to 
enhance the security of the system.

To disable root SSH access, you can modify the SSH configuration file (/etc/ssh/sshd_config) 
and set the "PermitRootLogin" option to "no". This will prevent the root user from logging 
in remotely via SSH. Alternatively, you can create a separate user account with administrative 
privileges and grant it SSH access instead of using the root user account.

It's worth noting that disabling root SSH access does not mean that the root user is 
disabled entirely. The root user can still log in to the system locally or use other 
tools like sudo to perform administrative tasks on the system. The aim is to limit the 
exposure of the root account to the network, thereby reducing the attack surface of the system.

----------------------------------------------------------------------------------------------

UFW on Debian

UFW (Uncomplicated Firewall) is a user-friendly command-line interface for managing the 
built-in firewall of Debian and other Linux-based systems. LVM (Logical Volume Manager) 
is a tool that allows you to manage storage devices, such as hard drives, and create 
logical volumes that can span multiple physical disks.

When using UFW on Debian with LVM, the firewall rules are applied at the network 
interface level, regardless of whether the underlying storage is managed by LVM or not. 
Therefore, the fact that you are using LVM to manage your storage devices does not affect 
how UFW works or how you configure the firewall rules.

----------------------------------------------------------------------------------------------

Finally, you have to create a simple script called monitoring.sh. It must be devel-
oped in bash.
At server startup, the script will display some information (listed below) on all ter-
minals every 10 minutes (take a look at wall). The banner is optional. No error must
be visible.
Your script must always be able to display the following information:
• The architecture of your operating system and its kernel version.
• The number of physical processors.
• The number of virtual processors.
• The current available RAM on your server and its utilization rate as a percentage.
• The current available memory on your server and its utilization rate as a percentage.
• The current utilization rate of your processors as a percentage.
• The date and time of the last reboot.
• Whether LVM is active or not.
• The number of active connections.
• The number of users using the server.
• The IPv4 address of your server and its MAC (Media Access Control) address.
• The number of commands executed with the sudo program.

During the defense, you will be asked to explain how this script
works. You will also have to interrupt it without modifying it.
Take a look at cron.

----------------------------------------------------------------------------------------------

#!/bin/bash
# Bash script

wall "
Operating System: $(. /etc/os-release; echo "$NAME")
Kernel: $(uname -r)
CPU(s): $(nproc)
vCPU(s): $(cat /proc/cpuinfo | grep processor | wc -l)
$(free --mega | grep Mem | awk '{ printf("Memory Usage: %.0f/%.0fMB (%.2f%%)\n", $3, $2, $3/$2 * 100.0) }')
$(df -h . | sed 1d | awk '{ printf("Disk Usage: %.2f/%.2fGb (%.0f%%)\n", $3, $4, $5) }')
$(grep 'cpu ' /proc/stat | awk '{ printf("CPU load: %.2f%%\n", ($2+$4)*100/($2+$4+$5)) }')
$(who -b | awk '{ print("Last reboot: "$3 " " $4) }')
Connections TCP: $(ss -tn src :4242 | grep -i "estab" | wc -l) ESTABLISHED
User log: $(who | wc -l)
Network: IP $(ip addr | grep "inet " | sed 1d | awk '{ print($2) }') ($(ip addr | grep ether | awk '{ print($2) }'))
Sudo: $(cat /var/log/sudo/sudo.log | wc -l | awk '{ print $1/2 }') cmd
$(if grep -q /dev/mapper /etc/fstab
	then
echo "LVM is in use"
	else
echo "LVM not in use"
	fi)
"

Operating System

    echo "Operating System: $(. /etc/os-release; echo "$NAME")"

    The /etc/os-release and /usr/lib/os-release files contain operating system identification data. 
	From that data, we're extracting the info of the $NAME variable.

Kernel

    echo "Kernel: $(uname -r)"

    The command uname prints system information. We use the command + the -r or --kernel-release 
	to print the kernel version.

CPU(s)

    echo "CPU(s): $(nproc)"

    The command nproc prints the number of processing units available.

vCPU(s)

    echo "vCPU(s): $(cat /proc/cpuinfo | grep processor | wc -l)"

    The /proc/cpuinfo file stores CPU and system architecture dependent items. From that, 
	we grep any available vCPU. First cpu will start with 0.

Memory Usage (as percentage)

    free --mega | grep Mem | awk '{ printf("Memory Usage: %.0f/%.0fMB (%.2f%%)\n", $3, $2, $3/$2 * 100.0) }'

    The free command displays the amount of free and used memory in the system. We use the --mega 
	flag to display the amount of memory in MB.

Disk Usage

    df -h . | sed 1d | awk '{ printf("Disk Usage: %.2f/%.2fGb (%.0f%%)\n", $3, $4, $5) }'

    The df command reports the file system disk space usage, using the option -h to print sizes 
	in powers of 1000 and specifying the file .. Then we use the command sed 1d to delete the first
	line of the output of the first command and use the data to display the info about the disk usage.

CPU Load

We start by using the command grep 'cpu' /proc/stat to
Last Reboot

    who -b | awk '{ print("Last reboot: "$3 " " $4) }' The command who will print information 
	about users who are currently logged in, while the option -b will print the time of the 
	last system boot.

TCP Connections

    echo "TCP Connections: $(ss -tn src :4242 | grep -i "estab" | wc -l) ESTABLISHED"

Creating a cron job

Each user, including root, can have a cron file. These files don't exist by default, but can 
be created using the crontab -e command that's also used to edit a cron file.

In the cron file, we will add the following lines:

   */10 * * * * /usr/local/bin/monitoring.sh
   @reboot sleep 20 && /usr/local/bin/monitoring.sh

The first line is the cron job that will execute every ten minutes (you can check out this 
https://crontab.guru/#*/10_*_*_* to better understand the cron syntax). The second line is to execute the script 20 seconds
after starting the server.